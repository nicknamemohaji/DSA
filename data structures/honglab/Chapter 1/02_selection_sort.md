# 선택 정렬 (Selection Sort)

> 알고리즘

1. 처음 인덱스부터 시작
2. 현재 인덱스부터 시작해, 정렬할 배열의 끝까지 가장 작은 원소의 인덱스를 찾는다
    - 가장 작은 원소를 현재 인덱스로 기록
    - 그 다음 원소와 비교해 다음 원소가 크다면 가장 작은 원소를 다음 원소로 기록
    - 배열의 끝까지 이 과정을 반복
3. 만약 가장 작은 원소의 인덱스가 현재 인덱스가 아니라면 둘을 교환(swap)한다
    - 별도의 메모리 공간을 할당하지 않기 위해 교환하는 방법 사용
    - 이 과정을 마치고 나면 현재 인덱스까지는 정렬된 상태
4. 인덱스를 다음 원소로 설정하고, 2, 3의 과정을 배열의 끝까지 반복한다
    - 3을 거치고 나면 현재 인덱스까지는 정렬된 상태라는 점을 이용
    - 배열의 끝은 어차피 비교할 대상이 없으므로 조기 종료 가능

> C++ 구현

```c++
for (int i = 0; i < size - 1; i++)
// 알고리즘상 가장 마지막 원소는 비교할 대상이 없으므로 이전까지만 비교
{
    int min_index = i;
    for (int j = i + 1; j < size; j++)
    {
        if (arr[min_index] > arr[j])
            min_index = j;
    }

    if (min_index != i)
        std::swap(arr[i], arr[min_index]);
}
```

> 특징

- `O(n ** 2)`의 시간복잡도
- Unstable Sort: 같은 키끼리의 원소 순서가 처음과 일치하지 않을 수 있다
    - Unstable Sort 예시: \[{2, a}, {2, b}, {1, c}] --> [{1, c}, {2, b}, {2, a}\]
    - Stable Sort 예시: \[{2, a}, {2, b}, {1, c}] --> [{1, c}, {2, a}, {2, b}\]
- 정렬 알고리즘의 비교기준: 성능(Time Complexity, Space Complexity), 안정성
