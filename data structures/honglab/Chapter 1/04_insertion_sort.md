# 삽입 정렬 (Insertion Sort)

> 알고리즘

1. 두번째 원소부터 시작한다
2. 왼쪽의 정렬된 부분에서 자기 자신이 들어가야 할 위치를 찾고 삽입한다
- 항상 인덱스 왼쪽은 정렬된 상태이다
- 배열 자료구조의 특성상 직접 삽입이 불가능하므로, 자기보다 큰 원소를 하나씩 오른쪽으로 미는 방법을 사용한다
    - 이진탐색을 사용하여 삽입할 위치를 찾더라도 배열 구조의 한계로 시간 개선은 불가능
    - 단, memcpy 등으로 블록 단위로 옮긴다면 이야기는 달라짐...
3. 인덱스를 하나씩 옮기며 배열의 끝까지 2를 반복한다

> c++ 구현

```c++
for (int i = 1; i < n; i++)
{
    int j = i;
    int key = arr[i];

    for (; j > 0 && arr[j - 1] > key; j--)
        arr[j] = arr[j - 1];
    arr[j] = key;
}
```

> 특징

- `O(n ** 2)`의 시간복잡도
- Stable Sort
- 버블정렬에 비해 효율적
    - 공통점: best case에서 불필요한 연산 없이 n번만으로 조기 종료 가능
    - Swap 연산: 두 번의 접근, 세 번의 쓰기, 하나의 임시변수
    - Shift 연산: 한 번의 접근, 한 번의 쓰기, 임시변수 필요 없음
