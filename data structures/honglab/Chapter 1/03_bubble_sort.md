# 버블 정렬 (Bubble Sort)

> 알고리즘

1. 처음 인덱스부터 시작
2. 현재 인덱스부터 시작해, 다음 원소와 비교해 다음 원소가 크다면 둘을 교환(swap)한다
3. 인덱스를 다음 원소로 설정하고, 2의 과정을 배열의 끝까지 반복한다
4. 과정 2, 3을 n번 반복한다
    - 2, 3의 과정을 '`i`th pass'라고 한다 (first pass, second pass, ...)
    - 과정 3을 i번 했으면, 뒤에서부터 i개의 원소는 정렬된 상태이다
    - 따라서 배열의 끝까지 반복할 필요는 없고, (n - i)까지만 비교하면 됨

*추가 최적화* 배열이 정렬된 상태이면 교환이 일어나지 않는다. 플래그를 이용해 교환 여부를 확인하면 루프를 조기 종료할 수 있다.

> c++ 구현

```c++
bool swapped = true;
for (int i = 0; i < n && swapped; i++)
{
    swapped = false;
    for (int j = 0; j < (n - 1) - i; j++)
    {
        if (arr[j] > arr[j + 1])
        {
            std::swap(arr[j], arr[j + 1]);            
            swapped = true;
        }
    }
}
```

> 특징

- `O(n ** 2)`의 시간복잡도
- Stable Sort
- 조기종료 조건 설정 가능: 대부분이 정렬된 자료의 경우 효율적
    - 이미 정렬된 경우, 일부만 바꿔주면 되는 경우, ...
    - 단, 교환이 많이 필요하므로 랜덤한 자료의 경우 비효율적
